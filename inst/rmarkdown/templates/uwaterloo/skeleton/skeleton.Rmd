---
title: "Meta-Workflow"
author: "Miao Yu"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    df_print: paged
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,cache = T,message=T,warning=F)
sessionInfo()
```

![logo](logo.png)

# Optimization

```{r IPOpos,eval=FALSE}
library(IPO)
library(xcms)
peakpickingParameters <- getDefaultXcmsSetStartingParams('centWave')
# Demo data
path <- system.file("extdata/plasma", package = "rmwf")
# Uncomment this line to use your own data(suggested 3-5 pooled QC samples)
# path <- 'path/to/your/files'
# change to 5 for obitrap
peakpickingParameters$ppm <- 10
resultPeakpicking <- 
  optimizeXcmsSet(files = path, 
                  params = peakpickingParameters,
                  plot = F,
                  subdir = NULL)

optimizedXcmsSetObject <- resultPeakpicking$best_settings$xset
retcorGroupParameters <- getDefaultRetGroupStartingParams()
resultRetcorGroup <-
  optimizeRetGroup(xset = optimizedXcmsSetObject, 
                   params = retcorGroupParameters, 
                   plot = F,
                   subdir = NULL)
writeRScript(resultPeakpicking$best_settings$parameters, 
             resultRetcorGroup$best_settings)
para <- capture.output(writeRScript(resultPeakpicking$best_settings$parameters, resultRetcorGroup$best_settings), type = "message")
save(para,file = 'para.RData')
sessionInfo()
```

# Wrap function

```{r eval=T}
library(xcms)
library(Rmpi)
library(stringr)
getrtmz <- function(path,index = NULL){
  load('para.RData')
peakwidth <- as.numeric(unlist(str_extract_all(para[grepl('peakwidth',para)],'\\d+\\.*\\d*')))
ppm <- as.numeric(unlist(str_extract_all(para[grepl('ppm',para)],'\\d+')))
noise <- as.numeric(unlist(str_extract_all(para[grepl('noise',para)],'\\d+')))
snthresh <- as.numeric(unlist(str_extract_all(para[grepl('snthresh',para)],'\\d+')))
mzdiff <- as.numeric(unlist(str_extract_all(para[grepl('mzdiff',para)],'\\d+\\.*\\d*')))
prefilter <- as.numeric(unlist(str_extract_all(para[grepl('prefilter',para)],'\\d+\\.*\\d*')))
integrate <- as.numeric(unlist(str_extract_all(para[grepl('integrate',para)],'\\d+')))
profStep <- round(as.numeric(unlist(str_extract_all(para[grepl('profStep',para)],'\\d+\\.*\\d*'))),1)
center <- as.numeric(unlist(str_extract_all(para[grepl('center',para)],'\\d+')))
response <- as.numeric(unlist(str_extract_all(para[grepl('response',para)],'\\d+')))
gapInit <- as.numeric(unlist(str_extract_all(para[grepl('gapInit',para)],'\\d+\\.*\\d*')))
gapExtend <- as.numeric(unlist(str_extract_all(para[grepl('gapExtend',para)],'\\d+\\.*\\d*')))
factorDiag <- as.numeric(unlist(str_extract_all(para[grepl('factorDiag',para)],'\\d+')))
factorGap <- as.numeric(unlist(str_extract_all(para[grepl('factorGap',para)],'\\d+')))
localAlignment <- as.numeric(unlist(str_extract_all(para[grepl('localAlignment',para)],'\\d+')))
bw <- as.numeric(unlist(str_extract_all(para[grepl('bw',para)],'\\d+\\.*\\d*')))
mzwid <- as.numeric(unlist(str_extract_all(para[grepl('mzwid',para)],'\\d+\\.*\\d*')))
minfrac <- as.numeric(unlist(str_extract_all(para[grepl('minfrac',para)],'\\d+\\.*\\d*')))
minsamp <- as.numeric(unlist(str_extract_all(para[grepl('minsamp',para)],'\\d+')))
max <-  as.numeric(unlist(str_extract_all(para[grepl('max',para)],'\\d+')))
  files <- list.files(path,full.names = T,recursive = T)
  if(!is.null(index)){
    files <- files[index]
  }
  xset <- xcmsSet(files,
  method = "centWave",
  peakwidth       = peakwidth,
  ppm             = ppm,
  noise           = noise,
  snthresh        = snthresh,
  mzdiff          = mzdiff,
  prefilter       = prefilter,
  mzCenterFun     = "wMean",
  integrate       = integrate,
  fitgauss        = FALSE,
  verbose.columns = FALSE)
xset <- retcor( 
  xset,
  method         = "obiwarp",
  plottype       = "none",
  distFunc       = "cor_opt",
  profStep       = profStep,
  center         = center,
  response       = response,
  gapInit        = gapInit,
  gapExtend      = gapExtend,
  factorDiag     = factorDiag,
  factorGap      = factorGap,
  localAlignment = localAlignment)
xset <- group( 
  xset,
  method  = "density",
  bw      = bw,
  mzwid   = mzwid,
  minfrac = minfrac,
  minsamp = minsamp,
  max     = max)

xset <- fillPeaks(xset)
return(xset)
}
```

# Peaks list

```{r eval=F}
library(enviGCMS)
# get the xcmsset object from demo data
path <- system.file("extdata/", package = "rmwf")
# use your own data
# path <- 'path/to/your/file'
srm <- getrtmz(path)
saveRDS(srm,'srm.rds')
srm2 <- getmzrt(srm,name='srmpeaks',eic = T)
srmpeaks <- readRDS('srmpeaks.rds')
srm <- readRDS('srm.rds')
plot(srmpeaks,srm,groupidx = groupnames(srmpeaks)[100])

query <- IRanges::IRanges(srm1$mzrange$mzmin,srm1$mzrange$mzmax)
subject <- IRanges::IRanges(srm3$mzrange$mzmin,srm3$mzrange$mzmax)
sum(IRanges::overlapsAny(query,subject) )
# back up the xcmsset object
save(srm,file = 'srm.Rdata')
# get the number
npeaks <- nrow(srm@groups)
# get the EIC, boxplot and diffreport, eixmax should be equal to the numbers of peaks groups in the pos objects 
report <- CAMERA::annotateDiffreport(srm,filebase = 'peaklistneg',metlin = T, eicmax = npeaks, classeic = srm@phenoData$class)
# save the report as a csv file
write.csv(report,file = 'all.csv')
# get the csv file for Metaboanalyst.ca
enviGCMS::getupload(srm,name = 'metabo')
```

# Peaks filtering

```{r}
load('srm.Rdata')
# get the peak intensity, m/z, retention time and group information as list
mzrt <- enviGCMS::getmzrt(srm)
# get the mean and rsd for each group
mzrtm <- enviGCMS::getdoe(mzrt)
gm <- mzrtm$groupmean
gr <- mzrtm$grouprsd
# find the blank group and pool QC group, demo data only have matrix blank
srm <- grepl('plasma',colnames(gm))
blk <- grepl('matrix',colnames(gm))
# pqc <- grepl('pool',colnames(gm))
# filter by pool QC and blank's group mean intensity(pool QC should larger than three times of blank), return numbers and index
# in demo data, use sample average intensity for each peak
sum(indexmean <- apply(gm,1,function(x) all(x[srm]>= 3*x[blk])))
# filt by pool qc rsd%, return numbers and index
# in demo data, use sample average intensity for each peak
rsdcf <- 30
sum(indexrsd <- apply(gr,1,function(x) ifelse(is.na(x[srm]),T,x[srm]<rsdcf)))
# overlap with rsd% and mean filter
sum(index <- indexmean&indexrsd)

# new list, update group and remove pool qc/blk
qcindex <- grepl('blank',mzrt$group$class) | grepl('pool',mzrt$group$class)
mzrtfilter <- list(data = mzrt$data[index,!qcindex],
                   mz = mzrt$mz[index],
                   rt = mzrt$rt[index],
                   group = droplevels(mzrt$group$class[!qcindex,drop =T]))
# get the filtered csv
enviGCMS::getupload(mzrtfilter,name = 'peakfilter')

```

# Normalization (Optional)

```{r}
# visulize the batch effect
mzrtsim::rlaplot(mzrt$data,lv = mzrt$group$class)
mzrtsim::ridgesplot(mzrt$data,lv = mzrt$group$class)
# get the simulation data and test on NOREVA
sim <- mzrtsim::simmzrt(mzrt$data)
mzrtsim::simdata(sim)
# correct the batch effect by sva
mzrtcor <- mzrtsim::svacor(mzrt$data,lv = mzrt$group$class)
# visulize the batch effect correction
li <- mzrtsim::limmaplot(mzrtcor,lv = mzrt$group$class)
# return the corrected data
mzrt$data <- mzrtcor$dataCorrected
```

# Statistical analysis

```{r}
# visulize the data
enviGCMS::plotmr(mzrtfilter,inscf = 4,rsdcf = 50)
# PCA
#enviGCMS::plotpca(mzrtfilter$data,
#                  as.character(mzrtfilter$group))
enviGCMS::plotpca(mzrtfilter$data,c('p','p','p'))

library(caret)
## Spliting data
trainIndex <- createDataPartition(mzrtfilter$data, p = .8, 
                                  list = FALSE, 
                                  times = 1)
## Get the training and testing datasets
Train <- data[ trainIndex,]
Test  <- data[-trainIndex,]
## Set the cross validation method
fitControl <- trainControl(## 10-fold CV
                           method = "repeatedcv",
                           number = 10,
                           ## repeated ten times
                           repeats = 10)
# extra papameters for GBM 
gbmGrid <-  expand.grid(interaction.depth = c(1, 5, 9), 
                        n.trees = (1:30)*50, 
                        shrinkage = 0.1,
                        n.minobsinnode = 20)

set.seed(825)
gbmFit <- train(mzrtfilter$group ~ ., data = training, 
                 method = "gbm", 
                 trControl = fitControl, 
                 verbose = FALSE, 
                 ## Now specify the exact models 
                 ## to evaluate:
                 tuneGrid = gbmGrid)
# show the fitting process
plot(gbmFit)  
# ANOVA analysis for model selection
anova(fit1,fit2)
# find the important variables
Imp <- varImp(fit)
plot(Imp)
```

# Annotation

```{r eval=FALSE}
library(xMSannotator)
num_nodes = 10
data("adduct_weights")
# get the xcmsset object
path <- system.file("extdata/plasma", package = "rmwf")
srmplasma <- getrtmz(path)
anno <- xsetplus::fanno(srmplasma,outloc = 'anno',mode = 'neg')
# annolipid <- xsetplus::fanno(neg,outloc = 'anno',
#                              db_name = 'LipidMaps')
```

# Pathway Analysis

```{r pathway}
# get the file
xsetplus::mumdata(srm,lv = mzrt$group$class)
# http://mummichog.org/index.html
# mummichog1 -f 'test.txt' -o myResult
```

# PMD analysis

```{r pmd}
load('srm.Rdata')
enviGCMS::getmzrt(srm,name = 'pmd')
options(shiny.maxRequestSize = 100*1024^2)
pmd::runPMD()
```

